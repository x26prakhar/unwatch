<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Hate Video</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%23000' d='M6 4h4v1H8v14h2v1H6v-1h2V5H6V4zm8 0h4v1h-2v14h2v1h-4v-1h2V5h-2V4z'/><rect fill='%23000' x='11' y='4' width='2' height='16'/></svg>">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>ihatevideo.txt</h1>
            <p>Tired of talks and podcasts being video-only? Mourning the transition to a post-literate society? Use this tool to take any YouTube link and convert it to a readable grammatical transcript, with chapters and top takeaways.</p>
        </header>

        <form id="transcribe-form">
            <div class="input-group">
                <input
                    type="url"
                    id="url-input"
                    placeholder="Paste YouTube URL here..."
                    required
                >
                <button type="submit" id="submit-btn">Textify</button>
            </div>
        </form>

        <div id="progress-container" class="hidden">
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <p id="progress-text">Starting...</p>
        </div>

        <div id="result-container" class="hidden">
            <div class="result-header">
                <h2 id="result-title"></h2>
                <div class="save-dropdown">
                    <button id="save-btn" class="download-btn">ðŸ’¾ Save â–¾</button>
                    <div class="save-menu" id="save-menu">
                        <button id="download-md-btn" class="save-option">Markdown (.md)</button>
                        <button id="download-pdf-btn" class="save-option">PDF (.pdf)</button>
                    </div>
                </div>
            </div>
            <div class="viewer-toolbar">
                <div class="font-dropdown">
                    <div class="font-combo" id="font-combo">
                        <span class="font-value" id="font-value">Times New Roman</span>
                        <span class="font-arrow"></span>
                    </div>
                    <div class="font-menu" id="font-menu">
                        <button class="font-option" data-font="Arial" style="font-family: Arial, sans-serif;">Arial</button>
                        <button class="font-option" data-font="Comic Sans MS" style="font-family: 'Comic Sans MS', cursive;">Comic Sans</button>
                        <button class="font-option" data-font="Georgia" style="font-family: Georgia, serif;">Georgia</button>
                        <button class="font-option" data-font="Tahoma" style="font-family: Tahoma, sans-serif;">Tahoma</button>
                        <button class="font-option selected" data-font="Times New Roman" style="font-family: 'Times New Roman', serif;">Times New Roman</button>
                        <button class="font-option" data-font="Wingdings" style="font-family: Wingdings;">Wingdings</button>
                    </div>
                </div>
                <div class="zoom-controls">
                    <button id="zoom-out" class="zoom-btn">âˆ’</button>
                    <span id="zoom-level">100%</span>
                    <button id="zoom-in" class="zoom-btn">+</button>
                </div>
            </div>
            <div class="ruler">
                <div class="ruler-marks">
                    <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span>
                </div>
            </div>
            <div class="document-area">
                <div class="vertical-ruler">
                    <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span><span>10</span>
                </div>
                <div id="markdown-viewer"></div>
            </div>
        </div>

        <div id="error-container" class="hidden">
            <p id="error-text"></p>
        </div>

        <footer>
            <p>made with love + hate by <a href="https://jasmi.news" target="_blank">jasmine sun</a> + claude code</p>
        </footer>
    </div>

    <script>
        const form = document.getElementById('transcribe-form');
        const urlInput = document.getElementById('url-input');
        const submitBtn = document.getElementById('submit-btn');
        const progressContainer = document.getElementById('progress-container');
        const progressText = document.getElementById('progress-text');
        const progressFill = document.querySelector('.progress-fill');
        const resultContainer = document.getElementById('result-container');
        const resultTitle = document.getElementById('result-title');
        const markdownViewer = document.getElementById('markdown-viewer');
        const errorContainer = document.getElementById('error-container');
        const errorText = document.getElementById('error-text');

        let currentJobId = null;
        let processingStartTime = null;
        let timerInterval = null;

        // Check for URL parameter and auto-submit
        const params = new URLSearchParams(window.location.search);
        const autoUrl = params.get('url');
        if (autoUrl) {
            urlInput.value = autoUrl;
            setTimeout(() => form.dispatchEvent(new Event('submit')), 100);
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const url = urlInput.value.trim();
            if (!url) return;

            // Reset UI
            progressContainer.classList.remove('hidden');
            resultContainer.classList.add('hidden');
            errorContainer.classList.add('hidden');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Textifying...';
            progressFill.style.width = '10%';

            // Start timer
            processingStartTime = Date.now();
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);

            try {
                // Start transcription
                const response = await fetch('/transcribe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                currentJobId = data.job_id;
                pollStatus();
            } catch (error) {
                showError(error.message);
            }
        });

        let currentProgress = 10;

        function formatTime(seconds) {
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        }

        function getEstimatedRemaining() {
            if (!processingStartTime || currentProgress <= 10) return null;
            const elapsed = (Date.now() - processingStartTime) / 1000;
            const estimatedTotal = (elapsed / currentProgress) * 100;
            const remaining = Math.max(0, Math.ceil(estimatedTotal - elapsed));
            return remaining;
        }

        function updateTimer() {
            if (!processingStartTime) return;
            const remaining = getEstimatedRemaining();
            if (remaining !== null && remaining > 0) {
                const baseText = progressText.textContent.replace(/ \(~[^)]+\)$/, '');
                progressText.textContent = `${baseText} (~${formatTime(remaining)} left)`;
            }
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            processingStartTime = null;
            currentProgress = 10;
        }

        async function pollStatus() {
            try {
                const response = await fetch(`/status/${currentJobId}`);
                const data = await response.json();

                if (data.error && data.status !== 'error') {
                    throw new Error(data.error);
                }

                // Update progress bar based on step
                const steps = {
                    'Starting...': 10,
                    'Getting video info...': 20,
                    'Extracting transcript...': 40,
                    'Cleaning transcript with Gemini...': 60,
                    'Generating takeaways...': 80,
                    'Loaded from cache': 100
                };
                currentProgress = steps[data.progress] || 50;
                progressFill.style.width = currentProgress + '%';

                // Show progress with time estimate
                const remaining = getEstimatedRemaining();
                if (remaining !== null && remaining > 0 && currentProgress < 100) {
                    progressText.textContent = `${data.progress} (~${formatTime(remaining)} left)`;
                } else {
                    progressText.textContent = data.progress;
                }

                if (data.status === 'completed') {
                    progressFill.style.width = '100%';
                    showResult(data.result);
                } else if (data.status === 'error') {
                    throw new Error(data.error);
                } else {
                    // Keep polling
                    setTimeout(pollStatus, 1000);
                }
            } catch (error) {
                showError(error.message);
            }
        }

        function showResult(result) {
            stopTimer();
            progressContainer.classList.add('hidden');
            resultContainer.classList.remove('hidden');

            resultTitle.textContent = result.title;
            markdownViewer.innerHTML = marked.parse(result.markdown);
            document.title = result.title;

            submitBtn.disabled = false;
            submitBtn.textContent = 'Textify';
        }

        function showError(message) {
            stopTimer();
            progressContainer.classList.add('hidden');
            errorContainer.classList.remove('hidden');
            errorText.textContent = `Error: ${message}`;

            submitBtn.disabled = false;
            submitBtn.textContent = 'Textify';
        }

        // Font dropdown
        const fontCombo = document.getElementById('font-combo');
        const fontValue = document.getElementById('font-value');
        const fontMenu = document.getElementById('font-menu');
        let currentFont = 'Times New Roman';

        fontCombo.addEventListener('click', (e) => {
            e.stopPropagation();
            fontMenu.classList.toggle('show');
            saveMenu.classList.remove('show');
        });

        fontMenu.querySelectorAll('.font-option').forEach(option => {
            option.addEventListener('click', () => {
                const font = option.dataset.font;
                currentFont = font;

                // Update displayed text
                fontValue.textContent = option.textContent;

                // Update selected state
                fontMenu.querySelectorAll('.font-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');

                // Apply font to viewer
                markdownViewer.style.fontFamily = font + ', serif';
                markdownViewer.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(h => {
                    h.style.fontFamily = font + ', serif';
                });

                fontMenu.classList.remove('show');
            });
        });

        // Zoom controls
        const zoomIn = document.getElementById('zoom-in');
        const zoomOut = document.getElementById('zoom-out');
        const zoomLevel = document.getElementById('zoom-level');
        let currentZoom = 100;

        function updateZoom() {
            markdownViewer.style.fontSize = (12 * currentZoom / 100) + 'pt';
            zoomLevel.textContent = currentZoom + '%';
        }

        zoomIn.addEventListener('click', () => {
            if (currentZoom < 200) {
                currentZoom += 10;
                updateZoom();
            }
        });

        zoomOut.addEventListener('click', () => {
            if (currentZoom > 50) {
                currentZoom -= 10;
                updateZoom();
            }
        });

        // Save dropdown
        const saveBtn = document.getElementById('save-btn');
        const saveMenu = document.getElementById('save-menu');
        const downloadMdBtn = document.getElementById('download-md-btn');
        const downloadPdfBtn = document.getElementById('download-pdf-btn');

        saveBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            saveMenu.classList.toggle('show');
            fontMenu.classList.remove('show');
        });

        document.addEventListener('click', () => {
            saveMenu.classList.remove('show');
            fontMenu.classList.remove('show');
        });

        async function downloadFile(url, defaultFilename) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Download failed');
            }
            const blob = await response.blob();
            const filename = response.headers.get('Content-Disposition')?.match(/filename="?([^";\n]+)"?/)?.[1] || defaultFilename;

            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(a.href);
            a.remove();
        }

        downloadMdBtn.addEventListener('click', async () => {
            if (currentJobId) {
                try {
                    await downloadFile(`/download/${currentJobId}`, 'transcript.md');
                } catch (error) {
                    alert('Download failed: ' + error.message);
                }
                saveMenu.classList.remove('show');
            }
        });

        downloadPdfBtn.addEventListener('click', async () => {
            if (currentJobId) {
                try {
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Generating...';
                    const font = encodeURIComponent(currentFont);
                    await downloadFile(`/download/${currentJobId}/pdf?font=${font}&zoom=${currentZoom}`, 'transcript.pdf');
                } catch (error) {
                    alert('PDF download failed: ' + error.message);
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'ðŸ’¾ Save â–¾';
                }
                saveMenu.classList.remove('show');
            }
        });
    </script>
</body>
</html>
